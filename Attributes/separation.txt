Here's your `MemberTestDataAttribute` class with clear separation and comments indicating which parts are reused from `MemberDataAttributeBase` and which are new:

```csharp
namespace CsabaDu.DynamicTestData.xUnit.v3.Attributes
{
    [AttributeUsage(AttributeTargets.Method, AllowMultiple = true, Inherited = true)]
    public sealed class MemberTestDataAttribute : MemberDataAttributeBase
    {
        // REUSED CODE FROM BASE CLASS (with minor modifications) - START
        static readonly Lazy<string> supportedDataSignatures;

        static MemberTestDataAttribute() =>
            supportedDataSignatures = new(() =>
            {
                var dataSignatures = new List<string>(18);

                foreach (var enumerable in new[] { "IEnumerable<{0}>", "IAsyncEnumerable<{0}>" })
                    foreach (var dataType in new[] { "ITheoryDataRow", "object[]", "Tuple<...>" })
                        foreach (var wrapper in new[] { "- {0}", "- Task<{0}>", "- ValueTask<{0}>" })
                            dataSignatures.Add(string.Format(CultureInfo.CurrentCulture, wrapper, string.Format(CultureInfo.CurrentCulture, enumerable, dataType)));

                return string.Join(Environment.NewLine, dataSignatures);
            });

        public MemberTestDataAttribute(string memberName, params object[] arguments)
            : base(memberName, arguments)
        {
            DisableDiscoveryEnumeration = true;
        }

        /// <inheritdoc/>
        protected override ITheoryDataRow ConvertDataRow(object dataRow) =>
            dataRow is TheoryTestDataRow theoryTestDataRow ?
                theoryTestDataRow
                : base.ConvertDataRow(dataRow);

        // REUSED CODE FROM BASE CLASS (with modifications) - END

        // NEW CODE - START
        /// <inheritdoc/>
        public override ValueTask<IReadOnlyCollection<ITheoryDataRow>> GetData(
            MethodInfo testMethod,
            DisposalTracker disposalTracker)
        {
            MemberType ??= testMethod.DeclaringType
                ?? throw new InvalidOperationException("Test method declaring type is null.");

            var accessor =
                GetPropertyAccessor(MemberType)
                    ?? GetFieldAccessor(MemberType)
                    ?? GetMethodAccessor(MemberType)
                    ?? throw new ArgumentException(
                        string.Format(
                            CultureInfo.CurrentCulture,
                            "Could not find public static member (property, field, or method) named '{0}' on '{1}'{2}",
                            MemberName,
                            MemberType.SafeName(),
                            Arguments.Length > 0 ? string.Format(CultureInfo.CurrentCulture, " with parameter types: {0}", string.Join(", ", Arguments.Select(p => p?.GetType().SafeName() ?? "(null)"))) : ""
                        )
                    );

            var returnValue =
                accessor()
                    ?? throw new ArgumentException(
                        string.Format(
                            CultureInfo.CurrentCulture,
                            "Member '{0}' on '{1}' returned null when queried for test data",
                            MemberName,
                            MemberType.SafeName()
                        )
                    );

            if (returnValue is IEnumerable dataItems)
            {
                var result = new List<ITheoryDataRow>();

                foreach (var dataItem in dataItems)
                    AddToResult(dataItem, testMethod, ref result);

                return new(result.CastOrToReadOnlyCollection());
            }

            return GetDataAsync(returnValue, MemberType, testMethod);
        }

        async ValueTask<IReadOnlyCollection<ITheoryDataRow>> GetDataAsync(
            object? returnValue,
            Type type,
            MethodInfo testMethod)
        {
            var taskAwaitable = returnValue.AsValueTask();
            if (taskAwaitable.HasValue)
                returnValue = await taskAwaitable.Value;

            if (returnValue is IAsyncEnumerable<object?> asyncDataItems)
            {
                var result = new List<ITheoryDataRow>();

                await foreach (var dataItem in asyncDataItems)
                    AddToResult(dataItem, testMethod, ref result);

                return result.CastOrToReadOnlyCollection();
            }

            if (returnValue is IEnumerable dataItems)
            {
                var result = new List<ITheoryDataRow>();

                foreach (var dataItem in dataItems)
                    AddToResult(dataItem, testMethod, ref result);

                return result.CastOrToReadOnlyCollection();
            }

            throw new ArgumentException(
                string.Format(
                    CultureInfo.CurrentCulture,
                    "Member '{0}' on '{1}' must return data in one of the following formats:{2}{3}",
                    MemberName,
                    type.SafeName(),
                    Environment.NewLine,
                    supportedDataSignatures.Value
                )
            );
        }

        private void AddToResult(object? dataItem, MethodInfo testMethod, ref List<ITheoryDataRow> result)
        {
            if (dataItem is ITheoryTestDataRow testDataRow)
            {
                if (testDataRow.ArgsCode == ArgsCode.Properties)
                {
                    testDataRow = testDataRow.SetTestDisplayName(testMethod.Name);
                }

                AddConverted(testDataRow, ref result);
            }
            else if (dataItem is not null)
            {
                AddConverted(dataItem, ref result);
            }
        }

        private void AddConverted(object dataRow, ref List<ITheoryDataRow> result) =>
            result.Add(ConvertDataRow(dataRow));
        // NEW CODE - END

        // REUSED CODE FROM BASE CLASS - START
        Func<object?>? GetFieldAccessor(Type? type)
        {
            FieldInfo? fieldInfo = null;
            foreach (var reflectionType in GetTypesForMemberResolution(type, includeInterfaces: false))
            {
                fieldInfo = reflectionType.GetRuntimeField(MemberName);
                if (fieldInfo is not null)
                    break;
            }

            return
                fieldInfo is not null && fieldInfo.IsStatic
                    ? (() => fieldInfo.GetValue(null))
                    : null;
        }

        Func<object?>? GetMethodAccessor(Type? type)
        {
            MethodInfo? methodInfo = null;
            var argumentTypes = Arguments is null ? [] : Arguments.Select(p => p?.GetType()).ToArray();
            foreach (var reflectionType in GetTypesForMemberResolution(type, includeInterfaces: true))
            {
                var methodInfoArray =
                    reflectionType
                        .GetRuntimeMethods()
                        .Where(m => m.Name == MemberName && ParameterTypesCompatible(m.GetParameters(), argumentTypes))
                        .ToArray();
                if (methodInfoArray.Length == 0)
                    continue;
                if (methodInfoArray.Length == 1)
                {
                    methodInfo = methodInfoArray[0];
                    break;
                }
                methodInfo = methodInfoArray.Where(m => m.GetParameters().Length == argumentTypes.Length).FirstOrDefault();
                if (methodInfo is not null)
                    break;

                throw new ArgumentException(
                    string.Format(
                        CultureInfo.CurrentCulture,
                        "The call to method '{0}.{1}' is ambigous between {2} different options for the given arguments.",
                        type!.SafeName(),
                        MemberName,
                        methodInfoArray.Length
                    ),
                    nameof(type)
                );
            }

            if (methodInfo is null || !methodInfo.IsStatic)
                return null;

            var completedArguments = Arguments ?? [];
            var finalMethodParameters = methodInfo.GetParameters();

            completedArguments =
                completedArguments.Length == finalMethodParameters.Length
                    ? completedArguments
                    : completedArguments.Concat(finalMethodParameters.Skip(completedArguments.Length).Select(pi => pi.DefaultValue)).ToArray();

            return () => methodInfo.Invoke(null, completedArguments);
        }

        Func<object?>? GetPropertyAccessor(Type? type)
        {
            PropertyInfo? propInfo = null;
            foreach (var reflectionType in GetTypesForMemberResolution(type, includeInterfaces: true))
            {
                propInfo = reflectionType.GetRuntimeProperty(MemberName);
                if (propInfo is not null)
                    break;
            }

            return
                propInfo is not null && propInfo.GetMethod is not null && propInfo.GetMethod.IsStatic
                    ? (() => propInfo.GetValue(null, null))
                    : null;
        }

        static IEnumerable<Type> GetTypesForMemberResolution(
            Type? typeToInspect,
            bool includeInterfaces)
        {
            HashSet<Type> interfaces = [];

            for (var reflectionType = typeToInspect; reflectionType is not null; reflectionType = reflectionType.BaseType)
            {
                yield return reflectionType;

                if (includeInterfaces)
                    foreach (var @interface in reflectionType.GetInterfaces())
                        interfaces.Add(@interface);
            }

            foreach (var @interface in interfaces)
                yield return @interface;
        }

        static bool ParameterTypesCompatible(
            ParameterInfo[] parameters,
            Type?[] argumentTypes)
        {
            if (parameters.Length < argumentTypes.Length)
                return false;

            var idx = 0;
            for (; idx < argumentTypes.Length; ++idx)
                if (argumentTypes[idx] is not null && !parameters[idx].ParameterType.IsAssignableFrom(argumentTypes[idx]!))
                    return false;

            for (; idx < parameters.Length; ++idx)
                if (!parameters[idx].IsOptional)
                    return false;

            return true;
        }
        // REUSED CODE FROM BASE CLASS - END
    }
}
```

Key points about the separation:
1. **Reused Code**: 
   - The static constructor and `supportedDataSignatures` field
   - The attribute constructor (with added `DisableDiscoveryEnumeration` setting)
   - The member accessor methods (`GetFieldAccessor`, `GetMethodAccessor`, `GetPropertyAccessor`)
   - The type resolution helper methods (`GetTypesForMemberResolution`, `ParameterTypesCompatible`)
   - The base `ConvertDataRow` method (with added check for `TheoryTestDataRow`)

2. **New Code**:
   - The modified `GetData` and `GetDataAsync` methods that now handle `ITheoryTestDataRow`
   - The `AddToResult` and `AddConverted` helper methods for processing test data rows
   - The logic for setting test display names based on method names

3. **Modifications**:
   - The `ConvertDataRow` override that adds support for `TheoryTestDataRow`
   - The `GetData` methods now include the test method context for display name generation

This separation clearly shows which parts are derived from the base class and which are new functionality specific to your test data attribute.